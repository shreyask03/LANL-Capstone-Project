import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import pandas as pd

# geometry
L, W, H = 0.3, 0.2, 0.15
c = 1 / np.sqrt(3)

thrusters = np.array([
    [ L,  W,  H,  c,  c,  c],
    [ L,  W, -H,  c,  c, -c],
    [ L, -W,  H,  c, -c,  c],
    [ L, -W, -H,  c, -c, -c],
    [-L,  W,  H, -c,  c,  c],
    [-L,  W, -H, -c,  c, -c],
    [-L, -W,  H, -c, -c,  c],
    [-L, -W, -H, -c, -c, -c],
])

# # B Matrix
# B = np.zeros((6, 8))
# for i in range(8):
#     x, y, z, tx, ty, tz = thrusters[i]
#     # moment arms must use geometry directly
#     B[:, i] = [tx, ty, tz,
#                (y * tz - z * ty),   # roll moment (about X)
#                (z * tx - x * tz),   # pitch moment (about Y)
#                (x * ty - y * tx)]   # yaw moment (about Z)

# B Matrix
B = np.zeros((6, 8))
for i in range(8):
    x, y, z, tx, ty, tz = thrusters[i]
    # apply geometry scaling directly — use actual lever arms, not normalized symmetry
    roll_moment  = (y * tz - z * ty) / W   # normalize by W so it scales with geometry
    pitch_moment = (z * tx - x * tz) / L   # normalize by L
    yaw_moment   = (x * ty - y * tx) / H   # normalize by H
    B[:, i] = [tx, ty, tz, roll_moment, pitch_moment, yaw_moment]


# DOFs
targets = {
    "Surge (+X)": np.array([1, 0, 0, 0, 0, 0]),
    "Sway (+Y)" : np.array([0, 1, 0, 0, 0, 0]),
    "Heave (+Z)": np.array([0, 0, 1, 0, 0, 0]),
    "Roll"      : np.array([0, 0, 0, 1, 0, 0]),
    "Pitch"     : np.array([0, 0, 0, 0, 1, 0]),
    "Yaw"       : np.array([0, 0, 0, 0, 0, 1]),
}

# solver
def forward_only_solve(B, tau_des, iters=6):
    f = np.zeros(8)
    residual = tau_des.copy()
    for _ in range(iters):
        delta, _, _, _ = np.linalg.lstsq(B, residual, rcond=None)
        f += delta
        f = np.maximum(f, 0)
        residual = tau_des - B @ f
    return f, B @ f

# DOF solutions
results = {}
for name, tau_des in targets.items():
    f, tau_actual = forward_only_solve(B, tau_des)
    f /= np.max(f) if np.max(f) > 0 else 1  # normalize
    results[name] = (f, tau_actual)

# summary
for name, (f, tau_actual) in results.items():
    print(f"\n=== {name} ===")
    print("Thruster RPMs:", np.round(f,3))
    print("Fx,Fy,Fz = ", np.round(tau_actual[:3],3))
    print("τx,τy,τz = ", np.round(tau_actual[3:],3))
    print("Residual error:", np.linalg.norm(tau_actual - targets[name]))

# # plot bar charts
# fig, axs = plt.subplots(2, 3, figsize=(14,6))
# axs = axs.flatten()

# for i, (name, (f, _)) in enumerate(results.items()):
#     ax = axs[i]
#     thruster_ids = np.arange(1, 9)
#     ax.bar(thruster_ids, f, color='royalblue', width=0.6)
#     ax.set_title(name)
#     ax.set_xlabel("Thruster #")
#     ax.set_ylabel("Scaled RPM")
#     ax.set_ylim(0, 1.05)
#     ax.set_xticks(thruster_ids)           # ✅ force labels 1–8
#     ax.set_xticklabels([str(k) for k in thruster_ids])
#     ax.grid(True, linestyle='--', alpha=0.5)

# plt.suptitle("Forward-Only Thrust Allocations (Scaled 0–1)", fontsize=14)
# plt.tight_layout()
# plt.show()

# 3D plot w/ thruster direction + moment vectors
fig = plt.figure(figsize=(14,10))
names = list(results.keys())

# Define spin directions (front view)
# CCW = +1, CW = -1
# Front 4 thrusters (1–4): [CCW, CW, CW, CCW]
# Rear 4 thrusters (5–8):  mirrored
spin_dirs = np.array([+1, -1, -1, +1,
                      -1, +1, +1, -1])

for i, name in enumerate(names):
    ax = fig.add_subplot(2, 3, i+1, projection='3d')
    f, _ = results[name]
    ax.set_title(name)
    ax.set_xlim([-0.4, 0.4])
    ax.set_ylim([-0.4, 0.4])
    ax.set_zlim([-0.4, 0.4])
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.view_init(elev=20, azim=35)

    # UUV Box
    corners = np.array([
        [ L,  W,  H], [ L, -W,  H], [-L, -W,  H], [-L,  W,  H],
        [ L,  W, -H], [ L, -W, -H], [-L, -W, -H], [-L,  W, -H]
    ])
    faces = [
        [corners[0], corners[1], corners[2], corners[3]],
        [corners[4], corners[5], corners[6], corners[7]],
        [corners[0], corners[1], corners[5], corners[4]],
        [corners[2], corners[3], corners[7], corners[6]],
        [corners[1], corners[2], corners[6], corners[5]],
        [corners[0], corners[3], corners[7], corners[4]]
    ]
    ax.add_collection3d(Poly3DCollection(faces, alpha=0.1,
                                         facecolor='gray', edgecolor='black'))

    total_spin = np.zeros(3)
    for j in range(8):
        x, y, z, tx, ty, tz = thrusters[j]
        thrust_dir = np.array([tx, ty, tz])
        spin_torque = spin_dirs[j] * f[j] * thrust_dir
        total_spin += spin_torque

        if f[j] > 1e-3:
            offset = 0.02
            ax.quiver(x + tx*offset, y + ty*offset, z + tz*offset,
                    spin_torque[0], spin_torque[1], spin_torque[2],
                    length=0.15 * f[j], color='red', normalize=True, lw=1.5)
            ax.quiver(x, y, z, tx, ty, tz,
                    length=0.15 * f[j], color='blue', normalize=True, lw=1.5)

        ax.scatter(x, y, z, color='black', s=20)
        ax.text(x+0.02, y+0.02, z+0.02, f"T{j+1}", fontsize=7)

    print(f"{name}: total spin torque ≈ {np.round(total_spin,3)}")



# force tested (10 N)
scale = 10.0
results_scaled = {}

for name, tau_des in targets.items():
    tau_des_10 = tau_des * scale
    f, tau_actual = forward_only_solve(B, tau_des_10)
    f /= np.max(f) if np.max(f) > 0 else 1
    results_scaled[name] = (f, tau_actual)

# collect Fx,Fy,Fz,Mx,My,Mz for each DOF
data = []
for name, (_, tau_actual) in results_scaled.items():
    Fx, Fy, Fz, Mx, My, Mz = np.round(tau_actual, 3)
    data.append([name, Fx, Fy, Fz, Mx, My, Mz])

df = pd.DataFrame(data, columns=["Case", "Fx [N]", "Fy [N]", "Fz [N]", "Mx [N·m]", "My [N·m]", "Mz [N·m]"])
print("\n=== Resulting Force & Moment Table (Target = 10 N or 10 N·m) ===\n")
print(df.to_string(index=False))



from matplotlib.lines import Line2D

legend_elements = [
    Line2D([0], [0], color='blue', lw=2, label='Thrust Vector'),
    Line2D([0], [0], color='red', lw=2, label='Spin Reaction Torque'),
    Line2D([0], [0], marker='o', color='w', markerfacecolor='black', markersize=6, label='Thruster Position')
]

fig.legend(handles=legend_elements, loc='upper right', fontsize=9)
plt.suptitle("3D Thruster Directions & Moment Vectors", fontsize=15, y=0.985)
plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.subplots_adjust(hspace=0.3)  # <-- add vertical spacing between rows
plt.show()
